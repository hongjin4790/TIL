# 데이터베이스 

## 데이터의 분류

정형 데이터: 미리 정해진 일정한 구조에 따라 저장된 데이터<br>
비정형 데이터: 일정한 구조가 없이 저장된 데이터<br>
파싱: 태그나 기타 마커를 통해 내부 구조를 파악하는 과정<br><br>


## 데이터베이스 시스템


<li>데이터베이스에 데이터를 저장하고, 이를 관리하여 조직에 필요한 정보를 생성해주는 시스템
<li>데이터베이스: 데이터의 집합
<li>데이베이스 관리 시스템(DBMS): 시스템의 데이터 중복성과 종속성 문제를 해결하기 위해 데이터를 통합하여 저장하고 관리하는 소프트웨어
<li>데이터베이스 시스템: 이를 총괄하는 체계

## 데이터베이스의 구조


### 스키마
<li>데이터베이스에 저장되는 데이터 모델을 기술
<li>자주 바뀌지 않는다는 것을 가정


### 인스턴스(instance) or 어커런스(Occurrence)
<li>데이터베이스에 실제로 저장된 현재의 값 또는 상태

![1](https://user-images.githubusercontent.com/29851704/147452882-95118ce2-fbe7-4b0f-85f3-17881db5435f.PNG)


### 3단계 데이터베이스 구조
![str](https://user-images.githubusercontent.com/29851704/147453046-51fadc11-7aec-469f-842a-96e3598e4541.PNG)

### 사상 or 매핑(Mapping)

<li>각 단계별 스키마들 간에 요청 및 결과 반환 과정
<li>외부-개념 사상: 응용 인터페이스라고도 한다
<li>개념-내부 사상: 저장 인터페이스라고도 한다

### 데이터 독립성
<li>하위 스키마 변경이 상위 스키마에 영향을 주지 않음
<li>논리적 데이터 독립성: 개념스키마가 변경시 외부-개념 사상 수정
<li>물리적 데이터 독립성: 내부 스키마가 변경시 개념-내부 사상 수정

### 데이터 사전
<li> 데이터에 대한 정보를 저장: 스키마, 다양한 제약조건, 설계 결정 사항, 응용 프로그램 설명 등을 저장


## 데이터베이스 관리 시스템(DBMS)

<li>데이터베이스를 정의하고 제어하는 프로그램
<li>DBMS의 장점: 데이터 중복성 제어, 여러 사용자에게 동시 공유, 접근 권한 통제를 통한 데이터 보안 향상, 데이터 백업과 장애 발생시 회복 제공, 데이터 접근에 대한 표준화, 응용 프로그램 개발 용이
<li>DBMS의 단점: 설치 및 운영 비용이 큼, 백업과 회복 방법이 복잡, 일부의 고장이 전체 시스템에 영향

## 데이터 모델

<li>데이터 추상화(Data Abstraction): 현실 세계에서 얻을 수 있는 데이터에서 세부 사항은 숨기고, 핵심 사항만 강조
<li>데이터 모델(Data Model): 데이터베이스의 구조를 기술하기 위해 사용되는 개념들의 집합
<li>데이터 구조: 데이터가 어떤 모습으로 저장되는지 나타내는 논리적 구조
<li>연산: 데이터구조에 맞게 값을 처리하는 과정
<li>제약 조건: 데이터가 유효하도록 규칙을 부여

### 개념적 데이터 모델
<li>사용자들이 데이터를 이해하는 개념적 구조를 표현
<li>Ex) 개체-관계 모델

### 논리적 데이터 모델
<li>개념적 구조를 데이터베이스가 이해하는 논리적 구조로 표현
<li>Ex) 관계 데이터 모델

## 개체-관계 모델(Entity-Relationship Model, E-R Model)
개체와 개체 간의 관계를 이용해 현실 세계를 개념적 구조로 표현
개체, 관계, 속성으로 구성

### 개체-관계 다이어그램(E-R Diagram)
<li>개체-관계 모델을 그림으로 표현한것

## 개체(Entity)
### 개체(Entity)
<li>현실 세계에서 다른 것들과 구별되어 존재하는 실체
<li>각 개체만의 고유한 특성을 가지고 있음(이름/특성/상태등)
<li>Ex) 게임-플레이어, 아이템, 맵

### 개체 타입(Entity Type)
<li>개체들의 이름과 속성

### 개체 인스턴스(Entity Instance)
<li>개체 타입에 따라 실제 값 또는 현재 값을 가지는 개체
<li>개체 어커런스(Entity Occurrence)

### 개체 집합(Entity Set)
<li>특정 개체 타입의 개체 인스턴스들의 집합

## 속성

### 속성(Attribute)
<li>개체나 관계의 특성을 기술
<li>가장 작은 의미있는 논리적 단위

### 단일 값 속성(Single-Valued Attribute)
<li>값을 하나만 가질 수 있는 속성
<li>Ex) 아이디 / 이름

### 다중 값 속성(Multi-Valued Attribute)
<li>값을 여러 개 가질 수 있는 속성
<li>Ex) 연락처 – 전화/이메일

### 단순 속성(Simple Attribute)
<li>의미를 더는 분해할 수 없는 속성
<li>Ex) 제품 가격

### 복합 속성(Composite Attribute)
<li>의미를 분해할 수 있는 속성
<li>Ex) 생년월일 – 년/월/일로 세분화 가능

### 유도 속성(Derived Attribute)
<li>하나의 속성이 저장된(Stored Attribute) 다른 속성의 값에서
유도되어 결정
<li>Ex) 가격과 할인율로 계산되는 판매가격

### 널 속성(Null Attribute)
<li>널 값이 허용되는 속성

### 키 속성(Key Attribute)
<li>각 개체 인스턴스를 찾아내는데 사용되는 속성
<li>모든 개체 인스턴스는 고유한 키 값을 가짐
<li>여러 속성들로 구성 가능
<li>Ex) 고객 개체의 아이디

## 관계

### 관계(Relationship)
<li>개체와 개체 사이의 의미 있는 대응 관계(Mapping)
<li>Ex) 고객 개체와 책 개체 간의 구매 관계

### 유형(Type)
<li>일대일(1:1) 관계
<li>일대다(1:n) 관계
<li>다대다(n:m) 관계

### 매핑 카디널리티(Mapping Cardinality)
<li> 관계를 맺는 두 개체 집합에서, 각 개체 인스턴스가 연관성을 맺고 있는 상대 개체 집합의 인스턴스 개수

### 참여
<li>개체 인스턴스가 관계 인스턴스에 연관되는 것

### 필수적 참여(전체 참여)
<li>모든 개체 인스턴스가 관계에 반드시 참여
<li>Ex)회사내의 모든 사원은 반드시 한 부서에 소속

### 선택적 참여(부분 참여)
<li>개체 인스턴스 중 일부만 관계에 참여
<li>Ex)한 명의 사원은 회사의 업무 중 일부에만 참여

### 종속성(Dependence)
<li>개체가 독자적으로 존재할 수 없으며 다른 개체의 존재 여부에 의존적
<li>존재 종속(Existence Dependence)

### 약한 개체(Weak Entity)
<li> 다른 개체가 존재해야 존재할 수 있는 개체

### 강한 개체(Strong Entity)
<li> 다른 개체의 존재 여부를 결정하는 개체

### 특징
<li> 강한 개체와 약한 개체는 일반적으로 일대다의 관계를 가짐
<li>약한 개체는 강한 개체와의 관계에 필수적으로 참여
<li> 약한 개체는 강한 개체의 키를 포함하여 키를 구성함


### 개체-관계 다이어그램(E-R Diagram)
![er](https://user-images.githubusercontent.com/29851704/147456770-b01ea028-f6a2-4392-8798-eced7fc9a2e1.PNG)

## 관계 데이터 모델

### 논리적 데이터 모델(Logical Data Model)
<li>개념적 구조를 데이터베이스의 논리적 구조로 변환
<li>사용자가 생각하는 데이터베이스의 구조

### 관계 데이터 모델(Relational Data Model)
<li>가장 많이 사용되는 논리적 데이터 모델
<li>하나의 개체에 대한 데이터를 하나의 릴레이션에 저장
<li>데이터베이스를 테이블 형태로 구성

### 기타 논리적 데이터 모델
<li> 계층 데이터 모델과 네트워크 데이터 모델
<li>다대다(n:m) 관계 표현이 어려움
<li>구조가 복잡하고, 데이터의 연산이 어려움

### 계층 데이터 모델
<li>트리(Tree) 형태로 개체 간에 부모-자식 관계
<li>하나의 관계만 정의

### 네트워크 데이터 모델

<li>그래프(Graph)행태로 개체들은 일대다 관계
<li>개체들 관계를 이름으로 구별

### 관계 데이터 모델의 기본 용어

|기본 용어|의미|
|------|:---:|
|릴레이션(Relation)|하나의 개체에 관한 데이터를 테이블의 구조로 저장한 것|
|속성(Attribute)|릴레이션의 열|
|투플(Tuple)|릴레이션의 행|
|도메인(Domain) |하나의 속성이 가질 수 있는 모든 값의 집합|
|차수(Degree)|하나의 릴레이션에서 속성의 전체 개수|
|카디널리티(Cardicality)|하나의 릴레이션에서 투플의 전체 개수|

### 릴레이션의 특성
<li>투플의 유일성: 하나의 릴레이션에는 동일한 투플이 존재할 수 없음
<li>투플의 무순서: 릴레이션에서 투플들은 특정 순서를 가지지 않음
<li>속성의 무순서: 릴레이션 스키마에서 속성들은 특정 순서를 가지지 않음
<li>속성의 원자성: 속성은 원자 값만 사용, 복합 속성이나 다중 값 속성 사용 불가

## 키
<li>릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합

### 유일성(Uniqueness)
<li>동일한 키값을 가지는 투플은 존재하지 않음

### 최소성(Minimality)
<li>유일성을 지키는데 필요한 최소한의 속성들로만 키를 구성함
<li>키를 이루는 속성들 중 하나라도 빠지면 유일성을 보장할 수 없음
<li>Ex) 학생 정보 – (학번, 주민번호) : 유일성(O), 최소성(X)

### 키의 종류

|종류|설명|
|------|:---:|
|슈퍼키(Super Key) |유일성을 만족하는 속성(또는 집합)|
|후보키(Candidate Key)|유일성과 최소성을 만족하는 속성(또는 집합)|
|기본키(Primary Key)|후보키 중에서 기본적으로 사용하기 위해 선택한 키|
|대체키(Alternate Key)|기본키로 선택되지 못한 후보키|
|외래키(Foreign Key)|다른 릴레이션의 기본키를 참조하는 속성(또는 집합)|

### 기본 키의 선택조건
<li>널(NULL)값 속성이 없을 것: 다른 투플들과의 구별을 위해 필요
<li>변경이 잦은 속성은 피할 것: 속성값이 바뀔 때마다 유일성 검증이 필요
<li>단순한 후보키를 선택: 자리수가 적거나 단순 문자열

## 무결성 제약 조건

### 무결성(Integrity)
<li>데이터가 정확하고 유효한 상태

### 무결성 제약 조건(Integrity Constraint)
<li>데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
<li>데이터베이스의 연산으로 변경된 상태가 유효한 상태가 되도록 강제

### 개체 무결성 제약 조건(Entity Integrity Constraint)
<li>기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙

### 참조 무결성 제약 조건(Referential Integrity Constraint)
<li>외래키는 참조할 수 없는 값을 가질 수 없는 규칙
<li>단, 널 값은 가질 수 있음

## 관계 데이터 연산

### 관계 데이터 연산
<li>관계 데이터 모델을 위한 연산

### 관계 대수
<li>릴레이션을 처리하는 연산자들의 집합
<li>하나 이상의 릴레이션에서 새로운 릴레이션을 유도함

### 합병 가능
<li>두 릴레이션의 속성의 숫자가 동일(차수가 동일)
<li>두 릴레이션에서 서로 대응되는 속성의 도메인이 동일

### 합집합(Union)
<li>R ∪ S -> Y
<li>Y는 R, S에 속하는 모든 투플로 구성
<li>차수(Y) = 차수(R) = 차수(S)
<li>카디널리티(Y) <= 카디널리티(R)+ 카디널리티(S)
<li>교환법칙과 결합법칙이 성립

### 교집합(Intersection)
<li>R ∩ S -> Y
<li>Y는 R, S에 속하는 모든 투플로 구성
<li>차수(Y) = 차수(R) = 차수(S)
<li>카디널리티(Y) <= 카디널리티(R)
<li>카디널리티(Y) <= 카디널리티(S)
<li>교환법칙과 결합법칙이 성립

### 차집합(Difference)
<li>R - S -> Y
<li>Y는 R에는 존재하지만, S에 존재하지 않는 투플로 구성
<li>차수(Y) = 차수(R) = 차수(S)
<li>카디널리티(Y) <= 카디널리티(R)
<li>교환법칙과 결합법칙이 성립하지 않음

### 카티션 프로덕트(Cartesian Product)
<li>R X S -> Y
<li>Y는 R, S의 투플들이 모두 조합된 투플들로 구성
<li>차수(Y) = 차수(R) + 차수(S)
<li>카디널리티(Y) = 카디널리티(R) x 카디널리티(S)
<li>교환법칙과 결합법칙이 성립

### 셀렉트(Select)
<li>σ조건식(R) → Y
<li>Y는 R에서 특정한 조건을 만족하는 투플들의 집합
<li>차수(Y) = 차수(R)
<li>카디널리티(Y) <= 카디널리티(R)

### 조건식
<li>비교식 or 프레디킷(Predicate)
<li>비교 연산자
<li>논리연산자
<li>하나의 조건식: <속성> <비교 연산자> <속성 or 상수>
<li>여러 조건식: <조건식1> <논리 연산자> <조건식2> <논리 연산자> <조건식3>
<li>교환 법칙과 결합 법칙이 성립

### 프로젝트(Project)
<li>ㅠ속성리스트(R) → Y
<li>Y는 R에서 주어진 속성으로만 이루어진 투플들의 집합
<li>차수(Y) ≤ 차수(R)
<li>카디널리티(Y) ≤ 카디널리티(R)

### 조인(Join)
<li>R⋈조건식S → Y
<li>Y는 R,S에서 조인 속성의 값이 같은 투플들의 조합
<li>조인 속성: 두 릴레이션이 모두 가지고 있는속성, 생략시 두 릴레이션에서 동일한 이름이 가지는 속성
<li>카티션 프로덕트와 셀렉트로 구현 가능

### 세타 조인(Theta Join, 𝜽-join)
<li>R⋈A𝜃BS → Y
<li>𝜽는 비교 연산자
<li>A는 R의 속성, B는 S의 속성
<li>차수(Y) = 차수(R) + 차수(S)
<li>조건식은 여러 조건을 결합 가능
<li>동일 조인(Equi-Join)
<li>자연 조인(Natural Join)

### 세미 조인(Semi-Join)
<li>R⋉S → Y
<li>Y는 S의 조인 속성에 해당 하는 R의 투플들의 집합
<li>차수(Y) = 차수(R)
<li>카디널리티(Y) ≤ 카디널리티(R)
<li>교환 법칙이 성립하지 않음
<li>조인과 프로젝트로 구현 가능

### 외부 조인(Outer-Join)
<li>R⋈+S → Y
<li>Y는 R,S 사이에 조인 속성이 일치하지 않는 투플도 포함
<li>속성이 없는 경우 널(Null) 값으로 처리
<li>두 테이블의 모든 정보를 한 번에 얻고 싶을 때 사용
<li>왼쪽 외부 조인: R의 모든 투플을 결과에 포함
<li>오른쪽 외부 조인: S의 모든 투플을 결과에 포함
<li>완전 외부 조인: R과 S의 모든 투플을 결과에 포함


### 디비전(Division)
<li>R÷S → Y
<li>Y는 S의 모든 투플과 관련이 있는 R의 투플들의 집합
<li>R은 S의 모든 속성을 포함
<li>차수(Y) ≤ 차수(R)
<li>카티션 프로덕트, 프로젝트, 차집합으로 구현 가능

## 정규화

### 이상 현상(Anomaly)
- 데이터베이스 설계 오류로 데이터 연산시 발생하는 문제
- 하나의 릴레이션에 관련 없는 속성들을 함께 존재

### 이상현상의 종류
- 삽입 이상(Insertion Anomaly)
    - 투플을 삽입하기 위해 불필요한 데이터도 함께 삽입
- 갱신 이상(Update Anomaly)
    - 중복된 데이터를 가지고 있는 투플들 중 일부 투플의 데이터만 변경되어 불일치 발생
- 삭제이상(Deletion Anomaly)
    - 투플을 삭제하면 필요한 데이터도 함께 삭제됨

### 함수 종속성(Functional Dependency, FD)

- X,Y가 릴레이션 R의 속성들의 부분 집합일 때, 임의의 X 값에 대해 대응되는 Y 값이 항상 하나
- X → Y(X는 결정자, Y는 종속자)
    - X가 Y를 함수적으로 “결정” or Y가 X에 함수적으로 “종속”
- 결정자는 기본키/후보키/다른 속성 값을 유일하게 결정하는 속성
    - 속성 자체의 의미로 판단
    - 현재 속성 값만으로 판단 불가
    - 인스턴스가 아닌 스키마 기준으로 판단

### 함수 종속 다이어그램
- 함수 종속 관계를 도식화하여 표현한 것

### 함수 종속의 종류
- 완전 함수 종속(Full Functional Dependency, FFD)
    - 결정자 X 에서 일부 속성을 제외하는 경우, X와 Y가 함수적 종속 관계가 성립하지 않음
    - 일반적으로 함수 종속은 완전 함수 종속을 의미
    - 예) 당첨여부는 {고객아이디, 이벤트번호}에 완전 함수 종속됨
- 부분 함수 종속(Partial Functional Dependency, PFD)
    - 부분 함수 종속(Partial Functional Dependency, PFD)
    - 예) 고객이름은 {고객아이디, 이벤트번호}에 부분 함수 종속됨
고객 이름은 고객아이디나 이벤트번호 중에 하나로 결정 가능

### 정규화의 개념
- 관련 있는 속성들로만 구성되도록 릴레이션을 재설계
- 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현
- 이상 현상이 발생하지 않는 올바른 릴레이션으로 만들어 가는 과정

### 무손실 분해
- 정규화 과정에서 릴레이션들은 의미상 동등한 릴레이션들로 분해
- 분해된 릴레이션들을 자연 조인하면 분해 전의 릴레이션으로 복원 가능


### 정규형(Normal Form, NF)

- 정규화된 정도
    - 제 1 정규형 / 제 2 정규형 / 제 3 정규형 / BCNF형 / 제 4 정규형 / 제 5 정규형
- 상위 차수 정규형은 하위 차수 정규형의 제약 조건을 포함함
- 모든 릴레이션이 제 5 정규형에 속해야만 바람직한 것은 아님
- 일반적으로 제 3 정규형이나 보이스/코드 정규형

### 제 1 정규형(First Normal Form, 1NF)
- 모든 속성의 도메인이 원자 값(Atomic Value)만 가능
- 관계 데이터베이스의 기본 요건

### 정규화 방법
- 원자 값만 가지도록 투플들을 분해
- 데이터 중복 발생 가능성이 존재
- 제 1 정규형을 만족하는 릴레이션도 이상 현상 발생 가능
- 등급은 고객 아이디나 이벤트 번호 중 하나에 종속인데, 기본키는 {고객아이디, 이벤트번호}
- 등급이나 할인율은 부분 종속


### 제 2 정규형(Second Normal Form, 2NF)
- 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속
-  제 1 정규형의 조건도 만족

### 정규화 방법
- 릴레이션을 분해하여 부분 함수 종속을 제거
- 제 2 정규형을 만족하는 릴레이션도 이상 현상 발생 가능
- 등급은 고객 아이디에 종속적이고, 할인율은 고객 아이디에 종속적이므로, 할인율은 고객 아
이디에 종속적
- 이행적 함수 종속이 발생


### 이행적 함수 종속(Transitive FD)
- X → Y와 Y → Z이면, X → Z가 성립
- Z가 X에 이행적으로 함수 종속

### 제 3 정규형(Third Normal Form, 3NF)
- 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 아님
- 제 2 정규형의 조건도 만족

### 정규화 방법
- 모든 속성이 기본키에 이행적 함수 종속이 되지 않도록 분해
- 제 3 정규형을 만족하는 릴레이션도 이상 현상 발생 가능
- 하나의 릴레이션에 여러 개의 후보키가 존재하는 경우
- 담당강사번호가 후보키가 아님에도 인터넷강좌 속성을 결정

### 보이스/코드 정규형(Boyce/Codd Normal Form, BCNF)
- 모든 결정자가 후보키
- 제 3 정규형의 조건도 만족(강한 제 3 정규형)

### 정규화 방법
- 모든 속성이 기본키에 이행적 함수 종속이 되지 않도록 분해

### 제 4 정규형
- 함수 종속이 아닌 다치 종속(Multi Valued Dependency, MVD)을 제거
- 보이스/코드 정규형도 만족

### 제 5 정규형
- 후보키를 통하지 않는 조인 종속 (Join Dependenc, JD)을 제거
- 제 4 정규형도 만족

### 정규화 과정
- 속성의 도메인이 원자 값으로만 구성(제 1 정규화)
-  부분 함수 종속 제거(제 2 정규화)
- 이행적 함수 종속 제거(제 3 정규화)
- 후보키가 아닌 결정자 제거(보이스/코드 정규화)




